<!doctype html><html lang=en><head><title>Diagonalising 2D Schrödinger Equation</title><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><link rel=stylesheet href=/application.cc971cdbc2ebfe7afcea9dcb21c92f48a71e3d942fc0029183f03684cb4b4137.css integrity="sha256-zJcc28Lr/nr86p3LIckvSKcePZQvwAKRg/A2hMtLQTc="><link rel=icon type=image/png href=/images/site/paper-plane-regular_inverted_hu_9166616b26135953.png><meta property="og:title" content="Orjan Ameye"><meta property="og:type" content="website"><meta property="og:description" content><meta property="og:image" content="/"><meta property="og:url" content="https://oameye.github.io/"><meta name=description content="Diagonalising 2D Schrödinger Equation"><script async src="https://www.googletagmanager.com/gtag/js?id=G-CPHDFQL1QQ"></script><script>var dnt,doNotTrack=!1;if(null&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CPHDFQL1QQ")}</script><script integrity="sha256-DO4ugzEwhTW1Id1UIWn0gUJWaebCYOypeTit6LW4QB4=">let theme=localStorage.getItem("theme-scheme")||localStorage.getItem("darkmode:color-scheme")||"light";theme==="system"&&(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?theme="dark":theme="light"),document.documentElement.setAttribute("data-theme",theme)</script></head><body class="type-posts kind-page" data-bs-spy=scroll data-bs-target=#TableOfContents data-bs-offset=80><div class="container-fluid bg-secondary wrapper"><nav class="navbar navbar-expand-xl top-navbar shadow" id=top-navbar><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button>
<i data-feather=sidebar></i>
</button>
<a class=navbar-brand href=/><img src=/images/site/paper-plane-regular_hu_376c49fc055415d7.png id=logo alt=Logo>
Orjan Ameye</a>
<button class="navbar-toggler navbar-light" id=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#top-nav-items aria-label=menu>
<i data-feather=menu></i></button><div class="collapse navbar-collapse dynamic-navbar" id=top-nav-items><ul class="nav navbar-nav ms-auto"><li class=nav-item><a class=nav-link href=/#home>Home</a></li><li class=nav-item><a class=nav-link href=/#about>About</a></li><li class=nav-item><a class=nav-link href=/#featured-posts>Featured Posts</a></li><li class=nav-item><a class=nav-link href=/#experiences>Experiences</a></li><li class=nav-item><a class=nav-link href=/#education>Education</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false>More</a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/#projects>Projects</a>
<a class=dropdown-item href=/#publications>Publications</a>
<a class=dropdown-item href=/#recent-posts>Recent Posts</a></div></li><div id=top-navbar-divider></div><li class=nav-item><a class=nav-link id=blog-link href=/posts>Posts</a></li><li class=nav-item><a class=nav-link id=note-link href=/notes>Notes</a></li></ul></div></div><img src=/images/site/paper-plane-regular_hu_376c49fc055415d7.png class=d-none id=main-logo alt=Logo>
<img src=/images/site/paper-plane-regular_inverted_hu_9166616b26135953.png class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/search><input type=text name=keyword placeholder=Search data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/posts/ data-filter=all>Posts</a></li><div class=subtree><li><a class=list-link href=/posts/automatic_differentiation/ title="Automatic differentiation">Automatic differentiation</a></li><li><a class="active list-link" href=/posts/eigenfunctions/ title="Ground state eigenfunctions">Ground state eigenfunctions</a></li><li><a class=list-link href=/posts/parametron/ title="Parametric resonator">Parametric resonator</a></li><li><a class=list-link href=/posts/quantum_fisher_information/ title="Quantum Fisher Information">Quantum Fisher Information</a></li><li><i data-feather=plus-circle></i><a class=list-link href> reproduced_papers</a><ul><li><a class=list-link href=/posts/bloch_oscillations/ title="Optica 3(9) 1014-1018 (2016)">Optica 3(9) 1014-1018 (2016)</a></li><li><a class=list-link href=/posts/phys_rev_a_56_4175_1997/ title="Phys. Rev. A 56, 4175 (1997)">Phys. Rev. A 56, 4175 (1997)</a></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class=content><div class="container p-0 read-area"><div class="hero-area col-sm-12" id=hero-area style=background-image:url(/posts/eigenfunctions/featured.png)></div><div class=page-content><div style=margin-bottom:80px></div><div class=title><h1>Diagonalising 2D Schrödinger Equation</h1></div><div class="author-profile ms-auto align-self-lg-center"><p class=text-muted>Monday, March 28, 2022 | 9 minutes</p></div><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/julia/ class="btn btn-sm btn-info">Julia</a></li><li class=rounded><a href=/tags/tutorial/ class="btn btn-sm btn-info">Tutorial</a></li></ul></div><div class=post-content id=post-content><p>The text and method is based on the following sources:</p><ul><li>Youtube, <em><a href=https://youtu.be/DF1SnjXZcbM target=_blank rel=noopener>2D Schrodinger Equation Numerical Solution in PYTHON</a></em>, (2022), Available at: (Accessed: 6 March 2022).</li><li>Alexvas, <em><a href=https://scicomp.stackexchange.com/q/25976 target=_blank rel=noopener>Discretization of Laplacian with boundary conditions</a></em>, (2017), Available at: (Accessed: 6 March 2022).</li><li>Thomas H. Pulliam, David W. Zingg., <em>Fundamental Algorithms in Computational Fluid Dynamics</em>, (2014), Springer.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#66d9ef>using</span> PyPlot, PyCall
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> LinearAlgebra
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> SparseArrays
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Arpack, KrylovKit
</span></span></code></pre></div><h2 id=two-dimensional-box>Two-dimensional box</h2><p>The goal is to solve the single particle Schrödinger equation in a two-dimensional box of length $2L$ of the Hamiltonian:
$$
\hat{h}=\frac{-\hbar^{2}}{2 m} \nabla^{2}+V(\mathbf{r}, t).
$$
The box can have a homogeneous Dirichlet boundary condition, i.e., the wave function evaluated at the border must vanish, or periodic boundary conditions. There can be a potential $V$ in the box. So let us a meshgrid of $\mathbf{x}$ and $\mathbf{y}$ coordinates.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span>N <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>L <span style=color:#f92672>=</span> <span style=color:#ae81ff>10.0</span>
</span></span><span style=display:flex><span>Δx² <span style=color:#f92672>=</span> (<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>L<span style=color:#f92672>/</span>N)<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> meshgrid(x, y)
</span></span><span style=display:flex><span>    X <span style=color:#f92672>=</span> [x <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> y, x <span style=color:#66d9ef>in</span> x]
</span></span><span style=display:flex><span>    Y <span style=color:#f92672>=</span> [y <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> y, _ <span style=color:#66d9ef>in</span> x]
</span></span><span style=display:flex><span>    X, Y
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>x <span style=color:#f92672>=</span> <span style=color:#66d9ef>LinRange</span>(<span style=color:#f92672>-</span>L, L, N)
</span></span><span style=display:flex><span>y <span style=color:#f92672>=</span> <span style=color:#66d9ef>LinRange</span>(<span style=color:#f92672>-</span>L, L, N)
</span></span><span style=display:flex><span>X, Y <span style=color:#f92672>=</span> meshgrid(x, y);
</span></span></code></pre></div><h2 id=potential>Potential</h2><p>The potential is chosen to be eightfold rotation symmetric quasicrystal, centered on $\mathbf{r}=0,$
$$
V(\mathbf{r})=V_{0} \sum_{k=1}^{4} \cos ^{2} \left(\mathbf{G}^k \cdot \mathbf{r}\right),
$$
where $V_{0}$ is the potential amplitude and the quantities $G^{k}$ are the lattice vectors of four mutually incoherent standing waves oriented at the angles $0^{\circ}, 45^{\circ}, 90^{\circ}$, and $135^{\circ}$, respectively. The lattice vectors have norm $\left|G^{k}\right|=\pi / a$.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#66d9ef>function</span> get_potential(x, y, V₀)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> V₀<span style=color:#f92672>*</span>(cos(pi<span style=color:#f92672>*</span>x)<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> cos(pi<span style=color:#f92672>*√</span><span style=color:#ae81ff>2</span><span style=color:#f92672>/</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>(x<span style=color:#f92672>+</span>y))<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> cos(pi<span style=color:#f92672>*</span>y)<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> cos(<span style=color:#f92672>-</span>pi<span style=color:#f92672>/</span>(<span style=color:#f92672>√</span><span style=color:#ae81ff>2</span>)<span style=color:#f92672>*</span>(x<span style=color:#f92672>-</span>y))<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>V <span style=color:#f92672>=</span> get_potential<span style=color:#f92672>.</span>(X,Y, <span style=color:#ae81ff>0.005</span>)
</span></span><span style=display:flex><span>fig <span style=color:#f92672>=</span> figure(figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>6.2</span>,<span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>contourf(X, Y, V, <span style=color:#ae81ff>50</span>)
</span></span><span style=display:flex><span>colorbar()
</span></span></code></pre></div><p><img src=/posts/eigenfunctions/output_6_0.png alt=png></p><h2 id=units>Units</h2><p>The Schrödinger equation is given by
$$ \left[\frac{-\hbar^{2}}{2 m} \nabla^{2}+V(\mathbf{r})\right] \psi(\mathbf{r}) = E\psi(\mathbf{r}),$$
Let us use the lattice spacing $a$ and the corresponding recoil energy $E_r = \pi^2\hbar^2/2ma^2$ as the space and energy units, respectively, such that we have</p><p>$$
\left[\frac{-\hbar^2}{2 m E_ra^2} \tilde{\nabla}^{2}+\frac{V(\mathbf{\tilde{r}})}{E_r}\right] \psi(\mathbf{\tilde{r}})
= \left[
\frac{-1}{\pi^2} \tilde{\nabla}^{2}+\tilde{V}_{0} \sum^4_k \cos^{2}\left(\tilde{\mathbf{G}}^{k} \cdot \tilde{\mathbf{r}}\right)
\right]
\psi(\mathbf{\tilde{r}})
= \tilde{E}\psi(\mathbf{\tilde{r}}),
$$</p><p>where $|\tilde{\mathbf{G}}_{k}|=\pi$, $\tilde{\mathbf{r}} = \frac{\mathbf{r}}{a}$, and $\tilde{E}=\frac{E}{E_r}$.</p><h2 id=discretize-in-one-dimension>Discretize in one dimension</h2><p>Rest us to discretize our Hamiltonian. The idea can be easily explained by the following <strong>finite difference approximation</strong> of the second derivative in one dimension
$$ \frac{d^2 \psi}{dx^2} \approx \frac{\psi_{i+1}-2\psi_i + \psi_{i-1}}{\Delta x^2}.$$</p><h3 id=dirichlet-boundary-conditions>Dirichlet boundary conditions</h3><p>Suppose we have $M=4$ interior points and $a$ and $b$ two boundary points, a mesh with four interior points $\Delta x=2L /(M+1)$, represented as follows
$$
\begin{aligned}
&\qquad \ \ \ \ a \ \ \ 1 \ \ \ 2 \ \ \ 3 \ \ \ 4 \ \ \ b \\\
&amp;x=- \ L \ - \ - \ - \ - \ \ L
\end{aligned}
$$
We impose Dirichlet boundary conditions, $u(-L)=u_{a}, u(L)=u_{b}$ and use the <strong>centered finite difference approximation</strong> at every point in the mesh. We arrive at the four equations:</p><p>$$
\left(d_{x x} u\right)_{1} =\frac{1}{\Delta x^{2}} (u_a - 2 u_1 + u_2)
$$</p><p>$$
\left(d_{x x} u\right)_{2} =\frac{1}{\Delta x^{2}} (u_1-2 u_2+u_3)
$$</p><p>$$
\left(d_{x x} u\right)_{2} =\frac{1}{\Delta x^{2}} (u_2-2 u_3+u_4)
$$</p><p>$$
\left(d_{x x} u\right)_{4} =\frac{1}{\Delta x^{2}}\left(u_3-2 u_4+u_b\right)
$$</p><p>Introducing
$$
\begin{aligned}
\vec{u}=\left( \begin{array}{c} \psi_{1} \\\ \psi_{2} \\\ \psi_{3} \\\ \psi_{4} \end{array} \right)
\quad
(\overrightarrow{b c})=\frac{1}{\Delta x^{2}} \left( \begin{array}{c} \psi_{a} \\\ 0 \\\ 0 \\\ \psi_{b} \end{array} \right)
\quad
A=\frac{1}{\Delta x^{2}} \left( \begin{array}{rrrr} -2 & 1 & & \\\ 1 & -2 & 1 & \\\ & 1 & -2 & 1 \\\ & & 1 & -2 \end{array} \right)
\end{aligned}
$$
we can rewrite in matrix form as
$$
\begin{aligned}
\frac{d^2 \psi}{dx^2} =\frac{1}{\Delta x^{2}}D= A \vec{\psi}+(\overrightarrow{b c})
\end{aligned}
$$</p><h3 id=periodic-boundary-conditions>Periodic boundary conditions</h3><blockquote><p>This subsection has to be tested and worked out. First try did not work.</p></blockquote><p>Suppose we have $M=8$ points on a linear <strong>periodic</strong> mesh, represented as follows
$$
\begin{aligned}
&\cdots \ \ \ 7 \ \ \ \ 8 \ \ \ \ \ \ a \ \ \ \ 1 \ \ \ \ 2 \ \ \ \ 3 \ \ \ \ 4 \ \ \ \ b \ \ \ \ 1 \ \ \ \ 2 \ \ \ \cdots \\\
&amp;x= \ - \ \ - \ \ -L \ \ - \ \ - \ \ - \ \ - \ \ L \ \ - \ \ -
\end{aligned}
$$
where we have that $\psi(L)=\psi(-L)$. It can be shown that the matrix representation is modified by
$$
\begin{aligned}
\frac{d^2 \psi}{dx^2} =\frac{1}{\Delta x^{2}}D_p=\frac{1}{\Delta x^{2}} \left( \begin{array}{rrrr} -2 & 1 & & 1 \\\ 1 & -2 & 1 & \\\ & 1 & -2 & 1 \\\ 1 & & 1 & -2 \end{array} \right)
\end{aligned}
$$</p><h2 id=discretize-in-two-dimensions>Discretize in two dimensions</h2><p>In <strong>two dimensions</strong>, the wavefunction is not a vector anymore but a matrix. However, we would like to write it back as vector via the transformation
$$
\left( \begin{array}{rrrr} \psi_{11} & \psi_{12} & \cdots & \psi_{1N} \\\ \psi_{21} & \psi_{22} & \cdots & \psi_{2N} \\\ \vdots & \vdots & \ddots & \vdots \\\ \psi_{N1} & \psi_{N2} & \cdots & \psi_{NN} \end{array} \right) \rightarrow \left( \begin{array}{c} \psi_{11} \\\ \psi_{12} \\\ \vdots \\\ \psi_{NN} \end{array} \right)
$$
The second derivative finite difference matrix must than be written as
$$
\frac{\partial^2 \psi}{\partial x^2} = \frac{1}{\Delta x^{2}} I \otimes D = \frac{1}{\Delta x^{2}} \left( \begin{array}{rrr} D & & \\\ & \ddots & \\\ & & D\end{array} \right)
$$
where $\otimes$ is the <strong>Kronecker product</strong>. The <strong>2D Laplacian</strong> can than be written as
$$
\nabla^{2} = \frac{\partial^2 \psi}{\partial x^2} + \frac{\partial^2 \psi}{\partial y^2} = \frac{1}{\Delta x^{2}} (I \otimes D + D \otimes I) = \frac{1}{\Delta x^{2}} D\oplus D
$$
where $\oplus$ is the <strong>Kronecker sum</strong>, and we used that we discretized space as a <strong>squared grid</strong>, i.e. $\Delta x^{2}=\Delta y^{2}$.</p><h2 id=hamiltonian>Hamiltonian</h2><p>Let us assume the homogeneous Dirichlet Boundary conditions $\psi(L, y) = \psi(-L, y) = \psi(x, L) = \psi(x, -L) = 0$. The <strong>discretized Schrödinger equation</strong> can then be written as
$$
\left[-\frac{1}{\pi^2}(D \oplus D) + \Delta x^2 \tilde{V} \right] \psi = \left( \Delta x^2 \tilde{E}\right) \psi,
$$
where $D$ has -2 on the main diagonal and 1 on the two neighboring diagonals and $\psi$ is a vector. One could define the potential in units of $\Delta x^2$; in other words <code>get_potential</code> actually returns $\Delta x^2 V$. However, we will leave $\Delta x^2$ in the kinetic term.
Now we construct
$$
\hat{h} = -\frac{1}{\Delta x^{2}\pi^2} D \oplus D + \tilde{V}
$$
such that the corresponding eigenvalues $\tilde{E}$ are in units of recoil energy $E_r$.
Let $T=-\frac{1}{\Delta x^{2}\pi^2} D \oplus D$ and $U = V$</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span>diag <span style=color:#f92672>=</span> ones(N); <span style=color:#75715e># vector of ones</span>
</span></span><span style=display:flex><span>diags <span style=color:#f92672>=</span> <span style=color:#66d9ef>Vector</span>([diag[begin<span style=color:#f92672>:</span>end<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>diag, diag[begin<span style=color:#f92672>:</span>end<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]]); <span style=color:#75715e># vector of vectors of the diagonals</span>
</span></span><span style=display:flex><span>D <span style=color:#f92672>=</span> sparse(Tridiagonal(diags<span style=color:#f92672>...</span>)) <span style=color:#75715e># creates the discretised 2nd derivative</span>
</span></span><span style=display:flex><span>T <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>/</span>(Δx²<span style=color:#f92672>*</span>pi<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span>) <span style=color:#f92672>*</span> (kron(D, sparse(I,N,N)) <span style=color:#f92672>+</span> kron(sparse(I,N,N), D))  <span style=color:#75715e>#N**2 x N**2 matrix</span>
</span></span><span style=display:flex><span>U <span style=color:#f92672>=</span> spdiagm(reshape(V, N<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>H <span style=color:#f92672>=</span> T<span style=color:#f92672>+</span>U;
</span></span></code></pre></div><p>Here we used the package <code>SparseArrays.jl</code> to make the computations faster. <strong>Sparse arrays</strong> are arrays that contain enough zeros that storing them in a special data structure leads to savings in space and execution time, compared to dense arrays.</p><h2 id=eigenvectors-and-eigenvalues>Eigenvectors and eigenvalues</h2><p>Now that we constructed our discretized Hamiltonian we can just exactly diagonalize our Hamiltonian to find the <strong>eigenvalues</strong> and <strong>eigenvector</strong>. We shall to this with the package <code>Arpack.jl</code> which is a <em>Julia</em> wrapper to a <em>FORTRAN 77</em> library designed to compute a few eigenvalues and corresponding eigenvectors of large sparse or structured matrices, using the <strong>Implicitly Restarted Arnoldi Method</strong> (IRAM) or, in the case of symmetric matrices, the corresponding variant of the <strong>Lanczos algorithm</strong>. Both are classified as <em>Krylov subspace based algorithms</em> (see wikipedia). It is used by many popular numerical computing environments such as <em>SciPy</em>, <em>Mathematica</em>, <em>GNU Octave</em> and <em>MATLAB</em> to provide this functionality.</p><p>We use the <code>eigs</code> function where <code>nev</code> specifies how many eigenvalues and eigenvectors we want and <code>which</code> specifies the type of eigenvalues to compute. For my purposes I only need the ground state wave function.</p><p>Alternatively, one could use <code>KrylovKit.jl</code>, a native Julia package collecting a number of Krylov-based algorithms for linear problems, singular value and eigenvalue problems and the application of functions of linear maps or operators to vectors. With <code>KrylovKit.jl</code> I manage to find better results if when I increase the number of point $N$. My theory is that it, as black box solver, uses another method above a certain threshold $N^*$, whereas <code>Arpack.jl</code> sticks to the same method and hence gives worse results.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#75715e># eigenvalues, eigenvectors = eigs(H, nev=1, which=:SM);</span>
</span></span><span style=display:flex><span>_, vecs, _ <span style=color:#f92672>=</span> eigsolve(H, <span style=color:#ae81ff>1</span>, <span style=color:#e6db74>:SR</span>);
</span></span><span style=display:flex><span><span style=color:#75715e># vecs[1]</span>
</span></span></code></pre></div><p>As we constructed the Hamiltonian to be a $N^2 \times N^2$ so that $\psi$ could be a vector, we have to reshape the eigenvectors back to a $N \times N$ matrix.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#66d9ef>function</span> get_e(n<span style=color:#f92672>::</span><span style=color:#66d9ef>Int64</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> reshape(vecs[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>&#39;</span>, N, N)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span>figure(figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>6.2</span>,<span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>pcolormesh(X, Y, get_e(<span style=color:#ae81ff>0</span>)<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span>, cmap<span style=color:#f92672>=</span><span style=color:#e6db74>:RdBu</span>)
</span></span><span style=display:flex><span>colorbar()
</span></span><span style=display:flex><span><span style=color:#75715e># contourf(X, Y, get_e(0)^2, 100)</span>
</span></span></code></pre></div><p><img src=/posts/eigenfunctions/output_20_0.png alt=png></p><h2 id=summary>Summary</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#66d9ef>using</span> PyPlot, PyCall
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> LinearAlgebra
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> SparseArrays
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Arpack, KrylovKit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> meshgrid(x<span style=color:#f92672>::</span><span style=color:#66d9ef>LinRange</span>{<span style=color:#66d9ef>Float64</span>, <span style=color:#66d9ef>Int64</span>}, y<span style=color:#f92672>::</span><span style=color:#66d9ef>LinRange</span>{<span style=color:#66d9ef>Float64</span>, <span style=color:#66d9ef>Int64</span>})<span style=color:#f92672>::</span><span style=color:#66d9ef>Tuple</span>{<span style=color:#66d9ef>Matrix</span>{<span style=color:#66d9ef>Float64</span>}, <span style=color:#66d9ef>Matrix</span>{<span style=color:#66d9ef>Float64</span>}}
</span></span><span style=display:flex><span>    X <span style=color:#f92672>=</span> [x <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> y, x <span style=color:#66d9ef>in</span> x]
</span></span><span style=display:flex><span>    Y <span style=color:#f92672>=</span> [y <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> y, _ <span style=color:#66d9ef>in</span> x]
</span></span><span style=display:flex><span>    X, Y
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> QC(x<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>, y<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>, V₀<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>)<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> V₀<span style=color:#f92672>*</span>(cos(pi<span style=color:#f92672>*</span>x)<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> cos(pi<span style=color:#f92672>*√</span><span style=color:#ae81ff>2</span><span style=color:#f92672>/</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>(x<span style=color:#f92672>+</span>y))<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> cos(pi<span style=color:#f92672>*</span>y)<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> cos(<span style=color:#f92672>-</span>pi<span style=color:#f92672>/</span>(<span style=color:#f92672>√</span><span style=color:#ae81ff>2</span>)<span style=color:#f92672>*</span>(x<span style=color:#f92672>-</span>y))<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> free(x<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>, y<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>, V₀<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>)<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> V₀<span style=color:#f92672>*</span>(<span style=color:#ae81ff>0</span><span style=color:#f92672>*</span>x<span style=color:#f92672>+</span><span style=color:#ae81ff>0</span><span style=color:#f92672>*</span>y)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> PC(x<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>, y<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>, V₀<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>)<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> V₀<span style=color:#f92672>*</span>(sin(pi<span style=color:#f92672>*</span>x)<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span>sin(pi<span style=color:#f92672>*</span>y)<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> eigenfunctionDBCArpack(V<span style=color:#f92672>::</span><span style=color:#66d9ef>Matrix</span>{<span style=color:#66d9ef>Float64</span>}, L<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>, N<span style=color:#f92672>::</span><span style=color:#66d9ef>Int64</span>)
</span></span><span style=display:flex><span>    Δx² <span style=color:#f92672>=</span> (<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>L<span style=color:#f92672>/</span>N)<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># creates the discretised 2nd derivative</span>
</span></span><span style=display:flex><span>    D <span style=color:#f92672>=</span> sparse(Tridiagonal(ones(N<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>), <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>ones(N), ones(N<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)))
</span></span><span style=display:flex><span>    <span style=color:#75715e># N**2 x N**2 matrix</span>
</span></span><span style=display:flex><span>    T <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>/</span>(Δx²<span style=color:#f92672>*</span>pi<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span>) <span style=color:#f92672>*</span> (kron(D, sparse(I,N,N)) <span style=color:#f92672>+</span> kron(sparse(I,N,N), D))
</span></span><span style=display:flex><span>    U <span style=color:#f92672>=</span> spdiagm(reshape(V, N<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>    H <span style=color:#f92672>=</span> T <span style=color:#f92672>+</span> U;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _, eigenvector <span style=color:#f92672>=</span> eigs(H, nev<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, which<span style=color:#f92672>=</span><span style=color:#e6db74>:SM</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> reshape(eigenvector<span style=color:#f92672>&#39;</span>, N, N)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> eigenfunctionDBCKrylov(V<span style=color:#f92672>::</span><span style=color:#66d9ef>Matrix</span>{<span style=color:#66d9ef>Float64</span>}, L<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>, N<span style=color:#f92672>::</span><span style=color:#66d9ef>Int64</span>)
</span></span><span style=display:flex><span>    Δx² <span style=color:#f92672>=</span> (<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>L<span style=color:#f92672>/</span>N)<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># creates the discretised 2nd derivative</span>
</span></span><span style=display:flex><span>    D <span style=color:#f92672>=</span> sparse(Tridiagonal(ones(N<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>), <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>ones(N), ones(N<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)))
</span></span><span style=display:flex><span>    <span style=color:#75715e># N**2 x N**2 matrix</span>
</span></span><span style=display:flex><span>    T <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>/</span>(Δx²<span style=color:#f92672>*</span>pi<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span>) <span style=color:#f92672>*</span> (kron(D, sparse(I,N,N)) <span style=color:#f92672>+</span> kron(sparse(I,N,N), D))
</span></span><span style=display:flex><span>    U <span style=color:#f92672>=</span> spdiagm(reshape(V, N<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>    H <span style=color:#f92672>=</span> T <span style=color:#f92672>+</span> U;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _, vecs, _ <span style=color:#f92672>=</span> eigsolve(H, <span style=color:#ae81ff>1</span>,<span style=color:#e6db74>:SR</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># _, eigenvector = eigs(H, nev=1, which=:SM);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> reshape(vecs[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>&#39;</span>, N, N)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#75715e># function eigenfunctionPBC(V::Matrix{Float64})</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Δx² = (2*L/N)^2</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># # creates the discretised 2nd derivative</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># D = sparse(Tridiagonal(ones(N-1), -2*ones(N), ones(N-1)))</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># D[1, end] = 1.0</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># D[end, 1] = 1.0</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># # N**2 x N**2 matrix</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># T = -1/(Δx²*pi^2) * (kron(D, sparse(I,N,N)) + kron(sparse(I,N,N), D))</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># U = spdiagm(reshape(V, N^2))</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># H = T + U;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># N = size(V)[1]</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># # creates the discretised 2nd derivative</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># D = sparse(Tridiagonal(ones(N-1), -2*ones(N), ones(N-1)))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># _, eigenvector = eigs(H, nev=1, which=:SM);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     return reshape(eigenvector&#39;, N, N)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># end</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span>V₀ <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.8</span>
</span></span><span style=display:flex><span>L <span style=color:#f92672>=</span> <span style=color:#ae81ff>50.0</span>
</span></span><span style=display:flex><span>Δx² <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.1</span>
</span></span><span style=display:flex><span>N <span style=color:#f92672>=</span> <span style=color:#66d9ef>Int64</span>(div(<span style=color:#ae81ff>2</span>L, Δx²))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>X, Y <span style=color:#f92672>=</span> meshgrid(<span style=color:#66d9ef>LinRange</span>(<span style=color:#f92672>-</span>L, L, N), <span style=color:#66d9ef>LinRange</span>(<span style=color:#f92672>-</span>L, L, N));
</span></span><span style=display:flex><span>V <span style=color:#f92672>=</span> QC<span style=color:#f92672>.</span>(X, Y, V₀)
</span></span><span style=display:flex><span>ef <span style=color:#f92672>=</span> eigenfunctionDBCKrylov(V, L, N)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fig, axes <span style=color:#f92672>=</span> subplots(nrows<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, ncols<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>, figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>im1 <span style=color:#f92672>=</span> axes[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>pcolormesh(X[<span style=color:#ae81ff>450</span><span style=color:#f92672>:</span><span style=color:#ae81ff>550</span>,<span style=color:#ae81ff>450</span><span style=color:#f92672>:</span><span style=color:#ae81ff>550</span>], Y[<span style=color:#ae81ff>450</span><span style=color:#f92672>:</span><span style=color:#ae81ff>550</span>,<span style=color:#ae81ff>450</span><span style=color:#f92672>:</span><span style=color:#ae81ff>550</span>], V[<span style=color:#ae81ff>450</span><span style=color:#f92672>:</span><span style=color:#ae81ff>550</span>,<span style=color:#ae81ff>450</span><span style=color:#f92672>:</span><span style=color:#ae81ff>550</span>], cmap<span style=color:#f92672>=</span><span style=color:#e6db74>:RdBu</span>)
</span></span><span style=display:flex><span>colorbar(im1, ax<span style=color:#f92672>=</span>axes[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>im2 <span style=color:#f92672>=</span> axes[<span style=color:#ae81ff>2</span>]<span style=color:#f92672>.</span>pcolormesh(X[<span style=color:#ae81ff>450</span><span style=color:#f92672>:</span><span style=color:#ae81ff>550</span>,<span style=color:#ae81ff>450</span><span style=color:#f92672>:</span><span style=color:#ae81ff>550</span>], Y[<span style=color:#ae81ff>450</span><span style=color:#f92672>:</span><span style=color:#ae81ff>550</span>,<span style=color:#ae81ff>450</span><span style=color:#f92672>:</span><span style=color:#ae81ff>550</span>], ef[<span style=color:#ae81ff>450</span><span style=color:#f92672>:</span><span style=color:#ae81ff>550</span>,<span style=color:#ae81ff>450</span><span style=color:#f92672>:</span><span style=color:#ae81ff>550</span>]<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span>, cmap<span style=color:#f92672>=</span><span style=color:#e6db74>:RdBu</span>)
</span></span><span style=display:flex><span>colorbar(im2, ax<span style=color:#f92672>=</span>axes[<span style=color:#ae81ff>2</span>])
</span></span></code></pre></div><p><img src=/posts/eigenfunctions/output_23_0.png alt=png></p><pre><code>PyObject &lt;matplotlib.colorbar.Colorbar object at 0x000000006E89FF40&gt;
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#75715e># @pyimport matplotlib.animation as anim</span>
</span></span><span style=display:flex><span><span style=color:#75715e># using Base64</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># fig = figure(figsize=(6.2,5))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># function make_frame(i)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     V₀ = 0.02*i</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     L = 10.0</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     N = 150</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     X, Y = meshgrid(LinRange(-L, L, N), LinRange(-L, L, N));</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     V = QC.(X, Y, V₀)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     ef = eigenfunctionDBC(V)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     pcolormesh(X, Y, ef^2, cmap=:RdBu)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># withfig(fig) do</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     myanim = anim.FuncAnimation(fig, make_frame, frames=20, interval=200)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     myanim[:save](&#34;test2.mp4&#34;, bitrate=-1, extra_args=[&#34;-vcodec&#34;, &#34;libx264&#34;, &#34;-pix_fmt&#34;, &#34;yuv420p&#34;])</span>
</span></span><span style=display:flex><span><span style=color:#75715e># end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># function showanim(filename)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     base64_video = base64encode(open(filename))</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     display(&#34;text/html&#34;, &#34;&#34;&#34;&lt;video controls src=&#34;data:video/x-m4v;base64,$base64_video&#34;&gt;&#34;&#34;&#34;)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># end</span>
</span></span><span style=display:flex><span><span style=color:#75715e># showanim(&#34;test2.mp4&#34;)</span>
</span></span></code></pre></div></div><div class="row ps-3 pe-3"><div class="col-md-6 share-buttons"></div><div class="col-md-6 btn-improve-page"><a href=https://github.com/oameye/hugo-toha/edit/main/content/posts/eigenfunctions/index.md title="Improve this page" target=_blank rel=noopener><i class="fas fa-code-branch"></i>
Improve this page</a></div></div><hr><div class="row next-prev-navigator"><div class="col-md-6 previous-article"><a href=/posts/automatic_differentiation/ title="Automatic differentiation of a recursive partition function" class="btn filled-button"><div><i class="fas fa-chevron-circle-left"></i> Prev</div><div class=next-prev-text>Automatic differentiation of a recursive partition function</div></a></div><div class="col-md-6 next-article"><a href=/posts/parametron/ title="From harmonic oscillator to the parametron" class="btn filled-button"><div>Next <i class="fas fa-chevron-circle-right"></i></div><div class=next-prev-text>From harmonic oscillator to the parametron</div></a></div></div><hr></div></div></div><a id=scroll-to-top class=btn type=button data-bs-toggle=tooltip data-bs-placement=left title="Scroll to top"><i class="fas fa-chevron-circle-up"></i></a></section><section class=toc-section id=toc-section><div class=toc-holder><h5 class="text-center ps-3">Table of Contents</h5><hr><div class=toc><nav id=TableOfContents><ul><li><a href=#two-dimensional-box>Two-dimensional box</a></li><li><a href=#potential>Potential</a></li><li><a href=#units>Units</a></li><li><a href=#discretize-in-one-dimension>Discretize in one dimension</a><ul><li><a href=#dirichlet-boundary-conditions>Dirichlet boundary conditions</a></li><li><a href=#periodic-boundary-conditions>Periodic boundary conditions</a></li></ul></li><li><a href=#discretize-in-two-dimensions>Discretize in two dimensions</a></li><li><a href=#hamiltonian>Hamiltonian</a></li><li><a href=#eigenvectors-and-eigenvalues>Eigenvectors and eigenvalues</a></li><li><a href=#summary>Summary</a></li></ul></nav></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-start"></div></div></footer><script src=/application.d572847081d6f49d4af3880010a02bfcf047f2ab00c81d60f3843048d1e3ea4a.js integrity="sha256-1XKEcIHW9J1K84gAEKAr/PBH8qsAyB1g84QwSNHj6ko=" defer></script></body></html>